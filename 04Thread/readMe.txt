多线程

首先需要理解  进程！

进程：  我们应用程序的执行实例！有自己独立的内存空间和系统资源！

 一个进程是由一个或者N个线程组成的！
 
线程：cpu调度和分配的基本单位！电脑中真正执行的是 线程！ 

 在同一个时间点，我们的电脑只能运行一个线程！
 
多线程：
     如果在一个进程中，同时运行多个线程，来完成不同的工作，我们称之为多线程！
     
   CPU上能同时运行多个线程吗？  不能！ 
      一个CPU在同一个时间点，只能运行一个线程，但是线程运行的速度太快，我们肉眼无法分辨
      所以我们认为是多线程！  



      
生活中进入地铁站的例子：

  场景1：现在地铁站有1个进站口，同时来了5个人旅客！
               需要排队进站！ 
  场景2：现在地铁站有5个进站口，同时来了5个人旅客！
               不需要排队进站！     
 
 哪个对我们的体验好点呢？
 哪个地铁的设计比较合理呢？

地铁站 ：CPU
进站口 ：线程


多线程的好处：
  01.充分的利用了CPU的资源
  02.给用户带来了良好的体验




实现多线程的方式：

 01.继承Thread类
 02.实现Runnable接口

Thread类   implements  Runnable接口

 Runnable接口中
 01. 只有一个方法run()
 02. 没有返回值
 03. 没有声明异常，其实现类的run（）如果出现了 异常不能声明，只能try catch
 
 
 
 
 
run()和 start()的区别：

   run()：
         01.就是一个普通的方法，称之为线程体！
         02.CPU分配给当前线程时间片的时候，run()开始执行

   start()：
         01.启动线程，不是立即执行线程！
         02.底层会默认执行run()
 
      
线程的生命周期：

    01.新生状态
       MyThreadDemo t1 = new MyThreadDemo();
    02.就绪状态
       t1.start();
    03.运行状态
       run();
    04.阻塞状态
      sleep ,yield, wait , join 
    05.死亡状态
       001.正常死亡      run()执行完毕 之后   
       002.异常死亡      run()执行过程中，出现异常退出！
         

线程的调度
     按照我们特定的方式给 多个线程设置CPU的使用权！
     
 01.线程的优先级
    setPriority()    优先级越高就一定先执行！ 不是的！ 只是一个概率问题
    
    
 02.join() 让新线程加入进来
    t1.join() ：必须等待t1线程执行完毕之后，其他的线程才能执行！
 
 03.线程的休眠
  sleep() 线程调用的时候，占用CPU资源不释放！其他线程就无法获取CPU资源了！
     其他线程需要等待！
   
  wait()  是Object类中的方法！  线程调用wait() 的时候，释放占用的CPU资源！
                01.其他线程继续执行！无需等待！
                02.使用了wait() 的线程，必须notify唤醒才能继续进入就绪状态！
 
 04.线程的礼让   yield      
              概率问题，我们t1线程想让t2线程执行，有可能t2不接收这个让渡！还是t1执行！    
                     
 05.线程的终止
   001. interrupt ： 设置线程的中断状态，不会终止，线程会继续执行！
		      如果有线程调用这个方法，那么这个线程的状态就是  中断状态！
		   我们怎么知道这个线程是不是中断状态呢？？？
		   isInterrupted可以判断线程的状态！
   002. interrupted：返回线程上次的中断状态！之后清除线程的中断状态！
   003. isInterrupted：返回线程是否是中断状态！
   004. wait(),sleep()如果执行了，会自动清除线程的中断状态！
     
     
  
并发：  
     在我们的操作系统中，同一个时间点，有N个线程都想访问同一个程序！但是cpu只能运行一个！
  
  这种情况就是！  多个线程在 同一个时间点 访问同一个资源，会引发线程不安全的问题！
  怎么解决这种不安全的问题？？
  01.设置同步代码块
  02.设置同步方法
    使用的关键字  synchronized  解决！
    
    注意点：
     01.在同一个时间点，只能有一个线程进入  synchronized代码块或者方法
     02.当一个线程访问 synchronized代码块的时候，其他的synchronized代码块也会被锁定！
     03.当一个线程访问 synchronized代码块的时候，其他的线程可以访问非synchronized修饰代码块！
    
    
    
  Runnable   Callable  的区别       Future接口


  01.Runnable接口中只有一个方法    public abstract void run();
             没有返回值  没有声明异常
  02.Callable接口中只有一个方法     V call() throws Exception;
             有返回值    有声明异常
  03.Callable 接口中的call()的返回值可以用 Future对象来接收
  
  
   Future是一中思想：
  
    1 2 3 4四个人在排队买煎饼！
    234是不是需要等待！ 假如一人需要等待5分钟！
        第四个人4需要等待15分钟！
        按照我们现在讲的线程！
    123得到煎饼，4必须等待15分钟之后才能得到！
        中间4不能离开队列，4白白等待15分钟！
        
        
   Future的核心：
    1 2 3 4四个人在排队买煎饼！
       假如一人需要等待5分钟！
    4知道自己需要等待15分钟！
       这时候4可以利用这15分钟去做别的事情！
    123买完煎饼之后，4会得到通知，然后回来购买煎饼！  
       







      
      

